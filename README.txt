gcは逆ポーランド記法の計算機です。
例えば「1 + 1」を計算したいときであれば、
「1_1_+」とgcに入力すれば答えが返ってきます。
下のコマンド表も参考にしてください。

gc コマンド一覧

' _ '  : 何もしない。数字入力の終わりを示す。 
' + '  : 足し算。上から1番目の要素と2番目の要素を足す。 
' - '  : 引き算。上から2番目の要素から1番目の要素を引く。
' * '  : 掛け算。上から1番目の要素と2番目の要素を掛ける。
' / '  : 割り算。上から2番目の要素から1番目の要素を割る。
' % '  : mod。上から2番目の要素から1番目の要素を割った余りを計算する。
' ? '  : 標準入力。ターミナルから数を一つ受け取る。
' P '  : 標準出力。一番上の要素をターミナルに表示する
' v '  : ルートの計算をする。一番上の要素をその要素の正の平方根に変える。
' R '  : 上から1番目と2番目の要素を交換する。
' E '  : 上から1番目と一番最後の要素を交換する。
' D '  : 1番上の要素を削除する。
' C '  : コピー。1番上の要素をコピーして、2つにして返す。
' I '  : 整数表示モードにする。偶数回すると元に戻る。
		例:「3_2_/P」→「1.555555」、「I3_2_/P」→「1」、「II3_2_/P」→「1.555555」
' pow ': 累乗。上から2番目の1番目乗を計算する。
' min ': 上から1番目と2番目のminを計算する。
' max ': 上から1番目と2番目のmaxを計算する。
' & '  : AND演算。上から1番目の要素と2番目の要素のANDを計算する。
' | '  : OR演算。上から1番目の要素と2番目の要素のORを計算する。
' ^ '  : XOR演算。上から1番目の要素と2番目の要素のXORを計算する。
' ~ '  : NOT演算。上から1番目の要素のNOTを計算する。
' == ' : 同値の比較演算子。if式の時、上から1番目の要素と2番目の要素を比較する。
' != ' : 非同値の比較演算子。if式の時、上から1番目の要素と2番目の要素を比較する。
' < '  : 小なりの比較演算子。if式の時、上から1番目の要素と2番目の要素を比較する。
' > '  : 大なりの比較演算子。if式の時、上から1番目の要素と2番目の要素を比較する。
' if ' : if式。上から1番目の要素と2番目の要素を比較する。
		例:「??if<(RD)(D)P」で「??maxP」と同義。




・使えるようになるまでの手引き
必要なもの :
 あなたのパソコン , C++のコンパイラ(GCC,Clangはこちらで動作確認済み)

あなたのパソコンが

Linuxの場合:
 ターミナルを開き、
  make
 と打ちましょう。
  それから
  .\gc
 と打てば動く！！gcが動く！！！
 
 試しに
  1_1_+P
 と入力してみましょう。
  2
 と出たら成功です。おめでとうございます。Happy!!!!!



windowsの場合:
 windowsマシンを使っている皆さんは、少し大変かもしれません。
 方法はいくつかあります。わかりやすいもの、簡単なものをえらんでやってみてください。
 
 方法1:直接コンパイルする。
  GCCが入っている皆さんは、ターミナルに
   g++ gc.cpp -o gc
  と打てばコンパイルできます。
  そのあと
   gc
  を実行します。

 試しに
  1_1_+P
 と入力してみましょう。
  2
 と出たら成功です。おめでとうございます。Happy!!!!!

 方法2:windows版makeを入れる
  調べてみたらwindows版makeなるものがあるらしいので、
  それを入れてmakeしてもOKなんじゃないかな～と思います。
  ただ、筆者はwindows版makeについての知識が0なので、よくわからないです。
  動作確認もしていないので、ちょっとうまくいくかわかりません。

 方法3:仮想マシン上で動かす
  ubuntuなどが入っている皆さんはLinuxマシンを持っている人の項目まで戻って、
  仮想マシンで実行してみてください。
  たぶん行けます。
